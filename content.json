{"meta":{"title":"Wenc的个人博客","subtitle":null,"description":null,"author":"Wenc","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"设计模式","slug":"DesignPatterns","date":"2018-08-28T06:12:12.000Z","updated":"2018-08-28T06:13:52.614Z","comments":true,"path":"2018/08/28/DesignPatterns/","link":"","permalink":"http://yoursite.com/2018/08/28/DesignPatterns/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库阶段学习","slug":"Database","date":"2018-08-15T11:19:56.000Z","updated":"2018-08-22T12:46:46.053Z","comments":true,"path":"2018/08/15/Database/","link":"","permalink":"http://yoursite.com/2018/08/15/Database/","excerpt":"MySQL学习DDL:操作数据库、表(Data Definition Language)数据库定义语言，用于操作数据库和表。 1.操作数据库：CRUD​ 1.创建数据库：C(Create)","text":"MySQL学习DDL:操作数据库、表(Data Definition Language)数据库定义语言，用于操作数据库和表。 1.操作数据库：CRUD​ 1.创建数据库：C(Create) 123create database 数据库名;create database if not exists 数据库名称; -- 判断不存在，再创建create database 数据库 character set 字符集合; -- 指定字符集 ​ 2.查询数据库：R(Retrieve) 查询时用关键字show。 12show databases; -- 查询所有数据库的名称show create table 数据库名称; -- 查询某个数据库的字符集：查询某个数据库的创建语句 ​ 3.修改数据库：U(Update) 修改时用关键字alter。 1alter database 数据库名称 character set 字符集合; #修改数据库的字符集 ​ 4.删除数据库：D(Delete)删除时用关键字drop。 12drop database 数据库名称; -- 删除数据库。drop database if exists 数据库名称; -- 判断存在，存在再删除。 ​ 5.使用数据库 12345select database(); --查询正在使用的数据库名称。use 数据库名称; #数据库名称。 #为mysql的方言注释-- sql注释/* sql多行注释 */ 2.操作表：CRUD​ 1.创建表：C(Create) 1234567891011121314create table 表名( 列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n);数据类型：整数类型 int 小数类型 double 日期 date 只包含年月日，yyyy-MM-dd 日期 datetime 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 时间戳类型 timestamp 包含年月日时分秒 yyyy-MM-dd HH:mm:ss -- 如果将来不给这个字段赋值，或者赋值为null，则使用当前系统时间来自动赋值。 字符串 varchar() -- 括号内必须定义大小复制表： create table 表名 like 被复制的表名; ​ 2.查询表：R(Retrieve) 查询时用关键字show。 12show tables; -- 查询某个数据库的所有表名称。desc 表名; -- 查询表结构。 ​ 3.修改表：U(Update) 修改时用关键字alter。 123456alter table 表名 rename to 新的表名; -- 修改表名。alter table 表名 character set 字符集名称; -- 修改表的字符集。alter table 表名 add 列名 数据类型; -- 添加一列。alter table 表名 chenge 列名 新列名 数据类型; -- 修改列的名称 类型。alter table 表名 modify 列名 新数据类型; -- 修改数据类型。alter table 表名 drop 列名; -- 删除列。 ​ 4.删除表：D(Delete)删除时用关键字drop。 12drop table 表名; -- 删除表drop table if exists 表名; -- 判断存在删除表。 DML:增删改表中的数据1.添加数据 1insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); 列名和值要一一对应；如果表名之后不定义列名，则默认给所有列添加值。 2.删除数据 123delete from 表名 [where 条件] --不加条件，则删除表中所有数据。truncate table 表名; --先删除表，然后再创建一张一模一样的表。 3.修改数据 1update 表名 set 列名1=值1,列名2=值2,.... [where 条件]; --如果不加任何条件，则会修改全部记录 DQL:查询表中的记录12select * from 表名;select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 123456789--多个字段查询 select 字段名1,字段名2... from 表名; select * from 表名;--去除重复 distinct select distinct 字段名1,字段名2... from 表名;去除重复--计算列 ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1为可能为null的字段，表达式2为表达式1是null时候的替换值--其别名 as:as 也可以省略 as跟在字段后面 1234567891011--条件查询 1.where子句后跟的条件 2.运算符 &gt; &lt; &lt;= &gt;= = &lt;&gt; between...and in(集合) Like 模糊查询 占位符 _:单个占位符 %:多个任意字符 is null and 或 &amp;&amp; or 或 || not 或 ！ 123-- 排序查询 order by 排序字段1 排序方式1,排序字段2 排序方式2...(多条判断时，前面的相等 才会判断后面的) ASC :升序 默认 DESC:降序 1234567-- 聚合函数将一列数作为一个整体，进行纵向计算1.count: 计算个数 一般选择非空的列：主键 #当含有null的列作为参数时，count会越过不做计算2.max：计算最大值3.min：计算最小值4.sum：计算和5.avg：计算平均值 12345-- 分组查询1.group by 分组字段;2.分组前后查询where和having的区别： 1.where在分组之前进行判断，having在分组之后进行判断 2.where后面不可以跟聚合函数，having之后可以进行聚合函数的判断 1234-- 分页查询1.limit 开始的索引,每页查询的条数;2.公式：开始索引=（当前页码-1）*每页显示的条数。limit是mysql的一个“方言” 约束1234567891011121314151617181920212223242526271.主键约束：primary key -- 主键非空且唯一，一张表只能有一个主键 创建表时添加主键约束：id int primary key; -- 一般主键约束添加在id字段后面。 创建完表之后添加：alter table 表名 mofify 字段名 字段类型 primary key; 删除主键：alter table 表名 drop primary key; 自动增长：-- 一般给主键id设置为自动增长 创建表时添加自动增长：添加在主键之后 auto_increment 创建完表之后添加：alter table 表名 modify 字段名 字段类型 auto_increment; 删除自动增长：alter table 表名 modify 字段名 字段类型；2.非空约束：not null 值不能为null 创建表时添加：添加在字段后面 not null 创建完表之后添加：alter table 表名 modify 字段名 字段类型 not null; 删除非空约束： alter table 表名 modify 字段名 字段类型;3.唯一约束：unique 创建表时添加：添加在字段后面 unique -- 唯一约束限定的字段可以有多个null值。 创建完表之后添加：alter table 表名 modify 字段名 字段类型 unique; 删除唯一约束：alter table 表名 drop index 字段名; -- 需要删除索引才能删掉唯一约束4.外键约束：foreign key -- 让表和表之间产生关系 在一对多的情况下在多的一方添加外键 创建表时添加：-- 新的一行 constraint 外键名称 foreign key (外键列名称) references 主表名称(主列名称) 创建表之后添加：alter table 表名 add constraint 外键名称 foreign key (外键列名称) references 主表名称(主列名称)； 删除外键约束：alter table 表名 drop foreign key 外键名称; 级联操作： -- 添加外键时将级联操作增加在外键后面 级联更新：on update cascade 级联删除：on delete cascade 数据库的三大范式 123第一范式（1NF）：每一列都是不可分割的原子数据项第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份与还原 12备份：mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径还原：登陆创建使用数据库之后：source 文件路径 多表查询123456789101.内连接查询 1.隐式内连接：select 表名1.字段名...,表名2.字段名... from 表名1，表名2 where 判断语句; 2.显示内连接：select 字段列表 from 表名1 [inner] join 表名2 on 条件;2.外连接查询 1.左外连接：select 字段列表 from 表名1 left [outer] join 表名2 条件; 2.右外连接：select 字段列表 from 表名1 right [outer] join 表名2 条件;3.子查询(查询的嵌套) 1.单行单列：子查询可以作为条件，使用运算符：&gt; &gt;= = &lt;= &lt; 2.多行单列：子查询可以作为条件，使用运算符in来判断 3.多行多列：子查询可以作为一张虚拟的表参与查询 事务123456789101112131415161718192021222324252627282930313233概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。开启事务：start transaction;回滚：rollback;提交：commit;mysql数据库默认自动提交，Oracle数据库默认是手动提交。查看事务的提交方式：select @@autocommit; -- 1代表自动提交 0 代表手动提交修改默认提交方式：set @@autocommit = 0;事务的四大特征：1.原子性：不可分割的最小操作单位，要么同时成功，要么同时失败。2.持久性：当事务提交或回滚后，数据库会持久化的保存数据。3.隔离性：多个事务之间相互独立。4.一致性：事务操作前后，数据总量不变。事务的隔离级别： 存在问题： 1.脏读：一个事务，读取到另一个事务中没有提交的数据。 2.不可重复读(虚读)：在同一个事务中，两次读取的事务不一样。 3.幻读：一个事务操作(DML)数据表中所有记录，另一个表中添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： 1.read uncommitted:读未提交 产生问题：脏读，不可重复读，幻读 2.read committed:读已提交(Oracle) 产生问题：不可重复读，幻读 3.repeatable read:可重复度(Mysql) 产生问题：幻读 4.serializable:串行化 解决了所有问题 隔离级别从小到大越来越安全，效率越来越低 数据库查询隔离级别： select @@tx_isolation; 数据库设置隔离级别： set global transaction isolation level 级别字符串; DCL：管理用户，授权1234567891.添加用户：create user '用户名'@'主机名' identified by '密码';2.删除用户：drop user '用户名'@'主机名';3.修改用户密码： update user set password=password('新密码') where user='用户名'; set password for '用户名'@'主机名' = password('新密码');4.查询用户： use mysql; select * from user; 通配符：%表示可以在任意主机使用用户登录数据库。 忘记root用户密码 1234567891.cmd --&gt; net stop mysql -- 停止mysql服务，需要管理员运行该cmd2.使用无验证方式启动mysql服务：mysqld --skip-grant-tables3.打开新的cmd窗口，直接输入mysql命令，敲回车。就可以登陆成功。4.use mysql;5.update user set password=password(&apos;新密码&apos;) where user=&apos;root&apos;；6.关闭两个窗口。7.打开任务管理器，手动结束mysqld.exe的进程8.启动mysql服务。9.使用新密码登录。 权限管理 12345671.查询权限 show grants for '用户名'@'主机名';2.授予权限 grants 权限列表 on 数据库名.表名 to '用户名'@'主机名'; 权限列表：All 所有权限 数据库.表名：*.*通配3.撤销权限 revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; JDBC123456789101112131415161718192021222324252627282930概念：Java Database Connectivity Java数据库连接本质：官方定义的一套操作所有数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库的jar包。我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类。1.DriverManager：驱动管理对象 1.注册驱动：告诉程序该使用哪一个数据驱动jar registerDriver(Driver driver) Class.forName(\"com.mysql.jdbc.Driver\") 2.获取数据库连接： Connection getConnection(String url, String user, String password) url:指定连接的路径 jdbc:mysql://ip地址(域名):端口号/数据库名称 user:用户名 password:密码2.Connection：数据库连接对象 1.获取执行sql的对象 Statement createStatement() PreparedStatement prepareStatemrnt(String sql) 2.管理事务 开启事务：setAutoCommit(boolean autoCommit)：调用该方法设置参数为false，即开启事务。 提交事务：commit() 回滚事务：rollback()3.Statement：执行sql的对象 1.执行sql boolean execute(String sql)：可以执行任意的sql。 2.int executeUpdate(String sql)：执行DML语句返回影响行数。 3.ResultSet executeQuery(String sql)：执行DQL语句。4.ResultSet：结果集对象，封装查询结果 boolean next()：游标向下移动一行，判断若为最后一行返回false，不是返回true。 getXxx(参数)：获取数据 一般用while循环获取数据。5.PreparedStatement：执行sql的对象 1.SQL注入问题：在拼接字符串时，有一些sql的特殊关键字参与字符串的拼接，会造成安全性的问题。 2.解决sql注入问题：使用PreparedStatement对象来解决。 3.预编译sql：参数使用?作为占位符 抽取JDBC工具类：JDBCUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; private JDBCUtils()&#123;&#125; /** * 静态代码块加载jdbc.properties文件，获取数据之后赋值给成员变量。 * 从文件中读取避免了传值的麻烦并且能够只读一次多次使用。 */ static &#123; try &#123; Properties pro = new Properties(); //通过类对象获取类加载器对象 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); //用类加载器对象获取指定路径的资源url对象 URL res = classLoader.getResource(\"jdbc.properties\"); //用url对象的getPath方法获取jdbc.properties文件的路径 String path = res.getPath(); //将文件以字符流的形式加载金propertirs集合 pro.load(new FileReader(path)); //通过指定的键获取对应值并赋值 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); //加载驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,user,password);//获取连接对象 &#125; public static void close(Statement stmt,Connection conn)&#123;//close方法的重载 close(null,stmt,conn); &#125; public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;//判断参数不为空关闭资源 if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 数据库连接池123456789101112131415161718192021221.概念：系统初始化好以后，连接池被创建，申请一些连接对象，用户访问数据库时从连接池中获取连接对象，访问完之后，会将对象归还给连接池。2.优点：节约资源，用户访问效率更高。3.接口DataSource 获取连接：getConnection 归还连接：close 线程池中获取的连接执行close方法不是关闭连接，而是归还连接。 以下两种常用实现 1.C3P0：数据库连接池技术。 2.Druid：数据库连接池技术，由阿里巴巴提供的。4.C3P0：数据库连接池技术 1.导入jar包 c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar 2.定义配置文件： 名称：c3p0.properties 或者 c3p0-config.xml 路径：将文件直接放在src目录下即可。 3.创建连接池对象 ComboPooledDataSource 4.获取连接：getConnection5.Druid：数据库连接池实现技术 1.导入jar包druid-1.0.9.jar 2.定义配置文件： 是properties形式的 可以叫任意名字，可以放在任意目录下 3.获取数据库连接池对象：通过工厂类来获取 DruidDataSourceFactory 4.获取连接 getConnection 抽取JDBC工具类：JDBCUtils—-使用druid连接池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//注释与上面抽取工具类的注释差不多，就不再一一注释public class JDBCUtils &#123; private static DataSource ds; static &#123; try &#123; Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; public static DataSource getDataSource() &#123; return ds; &#125; public static void close(Statement stmt, Connection conn) &#123; close(null, stmt, conn); &#125; public static void close(ResultSet rs, Statement stmt, Connection conn) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Spring JDBC1234567891011121314151617Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject()：查询结果，将结果封装为对象 一般用于聚合函数的查询","categories":[],"tags":[]},{"title":"Java高级阶段学习","slug":"Wenc","date":"2018-08-02T05:29:43.000Z","updated":"2018-08-19T13:32:39.501Z","comments":true,"path":"2018/08/02/Wenc/","link":"","permalink":"http://yoursite.com/2018/08/02/Wenc/","excerpt":"String,StringBuffer与StringBuilder的区别1.首先在执行速度上 StringBuilder&gt;StringBuffer&gt;String ​ 原因如下：String为字符串常量，StringBuilder和StringBuffer均为字符串变量。String对象创建之后不可更改，后面两种对象是变量，可以更改。 ​ 例如：String str=&quot;123&quot;; str+=&quot;456&quot;;这句代码，首先JVM创建一个新的String对象 str,把“123”赋值给str,接下来，JVM会再创建一个新的对象str，把原来str的值和“456”加起来再赋值给新的str,原来的str就被垃圾回收了。","text":"String,StringBuffer与StringBuilder的区别1.首先在执行速度上 StringBuilder&gt;StringBuffer&gt;String ​ 原因如下：String为字符串常量，StringBuilder和StringBuffer均为字符串变量。String对象创建之后不可更改，后面两种对象是变量，可以更改。 ​ 例如：String str=&quot;123&quot;; str+=&quot;456&quot;;这句代码，首先JVM创建一个新的String对象 str,把“123”赋值给str,接下来，JVM会再创建一个新的对象str，把原来str的值和“456”加起来再赋值给新的str,原来的str就被垃圾回收了。 注意：利用String方法进行大量数据操作时会出现堆内存溢出错误。 ​ StringBuilder和StringBuffer有append()方法添加任意类型的字符串。 2.StringBuilder和StringBuffer之间的区别 ​ StringBuilder线程上不安全的，StringBffer线程上是安全的。 ​ StringBuffer很多方法都带有synchronized关键字，则它的线程是安全的，但是StringBuilder则没有这些关键字，所以不能保证线程安全。 3.总结 ​ 1)操作少量数据则使用String ​ 2)单线程下操作大量数据用StringBuilder。 ​ 3)多线程下操作大量数据使用StringBuffer。 System类中的一个常用方法​ System类中的静态方法Long currentTimeMillis(); 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值。使用方式为： System.currentTimeMillis(); 通常用来计算程序所消耗的时间差值。 日期与日历​ Date类的两个构造函数： ​ Date() 分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 ​ Date(long date) 分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。 ​ Date类当中很多方法都被DateFormat和Calendar所取代，因此以下为DateFormat和Calendar两个类的学习笔记。 ​ DateFormat类是日期/时间格式化子类的抽象类，我们可以通过这个类帮我们完成Date对象和String对象之间的转换。分为格式化和解析两种转换方式。 ​ 常用规则为：y —-&gt; 年，M —-&gt; 月，d —-&gt; 日，H —-&gt; 时，m —-&gt; 分，s —-&gt; 秒 12345678910public static void main(String[] args) &#123; /* 格式化：将Date对象按照指定格式格式化为String对象 */ Date date = new Date(); //创建日期格式化对象，并指定格式 DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH-mm-ss\"); String str = df.format(date);//将Date对象格式化为字符串 System.out.println(str);//2018-08-04 13-22-32 &#125; 12345678910public static void main(String[] args) throws ParseException &#123; /* 解析：将String对象按照指定格式解析为Date对象 */ DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH-mm-ss\"); String str = \"2018-08-04 13-28-52\"; Date date = df.parse(str);//将字符串解析为Date对象 //由于parse抛出编译时期异常ParseException，所以我们在主方法中需要throws ParseException。 System.out.println(date);//Sat Aug 04 13:28:52 CST 2018 &#125; Calendar类是日历类，替换了Date类当中的很多方法，把时间信息封装为静态成员变量，方便获取各个时间的属性值。利用Calendar.getInstance()方法获取默认时区和语言环境的一个日历。 YEAR —-&gt; 年，MONTH —-&gt; 月（月份为0-11，可以+1使用），DAY_OF_MONTH —-&gt; 月中的天（几号），HOUR —-&gt; 时（12小时制），HOUR_OF_DAY —-&gt; 时（24小时制），MINUTE —-&gt; 分，SECOND —-&gt; 秒，DAY_OF_WEEK —-&gt; 周中的天（周几，周日为1，可以-1使用）。 1234567891011121314151617181920212223public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); //getTime()方法不是获取毫秒时刻，而是拿到对应的Date对象。 Date time = cal.getTime(); System.out.println(time);//Sat Aug 04 15:59:37 CST 2018 // 设置年 cal.set(Calendar.YEAR, 2018); // 设置月 此处设置的月份为8月 cal.set(Calendar.MONTH, 7); // 设置日 cal.set(Calendar.DAY_OF_MONTH, 4); //使用add()可进行增减操作 //cal.add(Calendar.DAY_OF_MONTH,-2);//减两个月 //获取星期几 int i = cal.get(Calendar.DAY_OF_WEEK); //星期是以星期日开头为1，因而得到的星期天数-1，即可得到星期值 System.out.println(\"今天是星期\" + (i - 1));//今天是星期6 &#125; 集合之Collection集合​ 集合是用来存储多个数据的容器。它的长度是可变的，并不固定。集合存储的都是对象，当有多个对象时，使用集合存储。 1.Collection集合两大子接口之List接口​ 有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。该接口有索引，并且可以存储重复元素。 ​ List集合的两个常用实现类——–ArrayList,它具有元素增删慢，查找快的特点，所以日常开发中查找、遍历比较多的情况下使用ArrayList比较合适。 ​ List集合的两个常用实现类——–LinkedList,它具有元素查找慢，增删快的特点，并且它提供了大量首尾操作的方法，因而在增删比较多的时候使用LinkedList。 2.Collection集合两大子接口之Set接口​ 一个不包含重复元素的 collection。此接口无索引，并且不能存储重复元素。当存储自定义类的时候，为了去重则需要重写equals和hashCode方法。 ​ Set接口的常用实现类———HashSet,此类实现 Set 接口，由哈希表支持。不能存储重复元素，并且存储无序（即存储的和取出的顺序有可能不一致）。并且查询速度比较快。若要实现存取顺序一致，可以使用LinkedHashSet. 3.Collection集合的遍历​ 1.迭代器遍历：当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 12345678910111213141516171819public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); coll.add(\"姚明\"); coll.add(\"科比\"); coll.add(\"麦迪\"); coll.add(\"科比1\"); coll.add(\"麦迪1\"); coll.add(\"科比2\"); coll.add(\"麦迪2\"); Iterator&lt;String&gt; it = coll.iterator(); while (it.hasNext())&#123; String s = it.next(); if(s.equals(\"麦迪1\"))&#123; it.remove();//解决并发异常 &#125; &#125; System.out.println(coll);&#125; ​ 注意：在遍历的过程中，如果想对集合进行数据的增删必须使用Iterator对象所有的增删方法，直接修改原集合会产生并发修改异常。 ​ 2.增强for遍历：增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 12345678910public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); for (String s : list) &#123; System.out.println(s); &#125; &#125; ​ 3.如果是List接口的实现类，还可以通过普通for循环利用索引来遍历数据。 4.泛型​ 泛型是可以在类或方法中预支地使用未知的类型。泛型的通配符为&lt;?&gt;， ​ 泛型的高级使用：类型名称 &lt;? extends 类 &gt; 对象名称 ——&gt; 只能接收该类型及其子类 ​ 类型名称 &lt;? super 类 &gt; 对象名称 ——&gt; 只能接收该类型及其父类型 5.外比较器与内比较器​ 内比较器实现Comparable接口泛型为实现类的本类类型或其父类类型，compareTo方法一个参数，this与这个参数之间进行数据比较。 12345678910public class Student implements Comparable&lt;Student&gt;&#123; ··········· @Override public int compareTo(Student o) &#123; if(this.score!=o.score)&#123; return (int)(o.score - this.score);//score为学生成绩 &#125; return this.age-o.age;//age为学生年龄 &#125;&#125; ​ 外比较器实现Comparator接口泛型为实现类的本类类型或其父类类型，实现compare方法两个参数之间进行数据比较。 12345678910public class MyComparator implements Comparator&lt;Student&gt; &#123; @Override public int compare(Student o1, Student o2) &#123; if(o1.getScore()!=o2.getScore())&#123; return (int)(o2.getScore()-o1.getScore());//score为学生成绩 &#125; return o1.getAge()-o2.getAge();//age为学生年龄 &#125;&#125; 集合之Map集合​ public interface Map&lt;K,V&gt; 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射一个值。这个集合存储的是键值对，它的键不允许重复，值可以重复，键对值是一一对应关系。 1.Map常用的实现类有HashMap和TreeMap。​ 接下来主要说一下HashMap。HashMap是基于哈希表的Map接口的实现。此实现提供所有可选的映射操作，并允许使用null值和 null键。它不能保证存取顺序一致（即存的数据和取的数据有可能不一致）。若想实现存储一致，可以使用LinkedHashMap。 1234567891011121314public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"杨过\", \"小龙女\");//给map中添加数据，添加成功则返回null String v2 = map.put(\"杨过\", \"郭芙\");//添加数据若键已经存在，则返回前一个被覆盖的value System.out.println(v1);//null System.out.println(v2);//小龙女 map.put(\"郭靖\", \"杨康\"); map.put(\"sd\", \"康\"); map.put(\"er\", \"gg\"); map.remove(\"er\");//移除数据，括号内放入键，移除了对应的value System.out.println(map);//&#123;sd=康, 杨过=郭芙, 郭靖=杨康&#125; &#125; 2.Map集合的两种遍历方法1234567891011121314151617181920212223242526272829303132331.使用keySet方法遍历public static void main(String[] args) &#123; //通过KeySet方法获取键的Set集合，再用迭代器和get方法遍历Map Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"迪丽热巴\", 170); map.put(\"古力娜扎\", 168); map.put(\"郑爽\", 169); Set&lt;String&gt; key = map.keySet(); Iterator&lt;String&gt; it = key.iterator(); while (it.hasNext()) &#123; String k = it.next(); Integer h = map.get(k); System.out.println(k + \"=\" + h); &#125; &#125;2.使用entrySet方法遍历public static void main(String[] args) &#123; //通过entrySet方法获得键值对entry对象的Set集合进行Map遍历 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"迪丽热巴\", 170); map.put(\"古力娜扎\", 168); map.put(\"郑爽\", 169); Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;String, Integer&gt; entry : set) &#123; String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key + \"=\" + value); &#125; &#125; 异常的处理1.异常处理的第一种方式throw​ throw用在方法内，用来抛出一个异常，将这个异常传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 1throw new ArrayIndexOutOfBoundsException(\"哥们！你越界了\"); 2.异常处理的第二种方式throws​ throws用在方法声明之上，表示不处理异常，交给方法的调用者来处理异常(抛出异常)。 使用格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 例如： 1public static void readFile() throws FileNotFoundException,IOException &#123;...&#125; 3.异常处理的第三种方式try…catch…finally​ try…catch…finally方法可以对Java中异常有针对性的语句进行捕获，可以对出现的指定方式进行处理。try代码块中编写可能出现异常的代码，catch用来进行某种异常的捕获，实现对捕获异常的处理。finally代码块当中无论异常是否发生，都需要执行。 使用格式： 12345678try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;finally&#123; finally代码块当中无论异常是否发生，都需要执行。&#125; 例如： 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; int num = 1; try &#123; System.out.println(\"0\"); System.out.println(10/num); readFile(\"a.txt\"); System.out.println(\"1\"); System.out.println(\"2\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;catch (ArithmeticException e)&#123; e.printStackTrace(); &#125;finally &#123; System.out.println(\"资源释放\"); &#125; //finally代码块当中无论异常是否发生，都需要执行。 System.out.println(\"后续代码\"); &#125; public static void readFile(String fileName) throws IOException &#123; if(!fileName.endsWith(\".txt\"))&#123; throw new IOException(\"后缀名不对\"); &#125; &#125; 注意：当catch语句中异常为父子关系时，父异常必须放在子异常的下面。 线程​ 线程是分时调度原则：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。还有抢占式调度原则：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。Java在微观上使用的是并发执行多线程。 1.线程的两种创建方式——-继承Thread类1234567891011121314151617181920212223public class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10 ; i++) &#123; System.out.println(getName() + \"正在执行！\" + i); &#125; &#125;&#125;public class Demo01 &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(\"新的线程\"); mt.start(); for (int i = 0; i &lt; 20 ; i++) &#123; System.out.println(\"main线程：\" + i); &#125; &#125;&#125; 2.线程的两种创建方式——-实现Runnable接口，把实现类对象作为参数传入Thread构造方法中。12345678910111213141516171819public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + \" \" + i); &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; MyRunnable mb = new MyRunnable(); Thread t = new Thread(mb, \"小强：\"); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"旺财：\" + i); &#125; &#125;&#125; 3.继承Thread和实现Runnable之间的区别实现Runnable接口比继承Thread类所具有的优势： ​ 1.适合多个相同的程序代码的线程去共享同一个资源。 ​ 2.可以避免java中的单继承的局限性。 ​ 3.增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 ​ 4.线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 4.线程同步—–synchronized关键字和Lock锁​ 1.synchronized同步代码块 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; ​ 注意：同步锁对象可以是任意类型，多个线程对象要使用同一把锁。 12345678910111213141516171819202122232425//售票案例public class SynchronizedRunnableImpl implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; synchronized (this) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖\" + ticket--); &#125; &#125; &#125; &#125;&#125; ​ 2.synchronized同步方法 1234567public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125;//对于非static方法,同步锁就是this。public static synchronized void method()&#123; 可能会产生线程安全问题的代码&#125;//对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 12345678910111213141516171819202122232425262728293031323334353637383940414243//售票案例public class SynchronizedRunnableImpl implements Runnable &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; payTicketStatic(); &#125; &#125; // public synchronized void payTicket() &#123;//synchronized(this)// if (ticket &gt; 0) &#123;// try &#123;// Thread.sleep(10);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;//// System.out.println(Thread.currentThread().getName() + \"正在卖\" + ticket--);// &#125;// &#125;// public static synchronized void payTicketStatic() &#123;// synchronized (SynchronizedRunnableImpl.class)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖\" + ticket--); &#125;// &#125; &#125;&#125; ​ 3.Lock锁 ​ 同步代码块/同步方法具有的功能Lock都有，Lock更加的面向对象。使用Lock lock = new ReentrantLock(); 获取Lock对象，加同步锁用lock()方法，释放同步锁用unlock()方法。 1234567891011121314151617181920212223242526272829//售票案例public class RunnableImpl implements Runnable &#123; private int ticket = 100; Lock l = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; l.lock(); if (ticket &gt; 0) &#123; try &#123; Thread.sleep(10); System.out.println(Thread.currentThread().getName() + \"正在卖\" + ticket--); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; l.unlock(); &#125; &#125; &#125; &#125;&#125; 5.线程等待唤醒机制​ 在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。wait方法与notify方法必须要由同一个锁对象调用。 经典案例——-生产者与消费者 包子类： 12345678public class BaoZi &#123; public String pi; public String xian; public boolean flag = false;&#125; 包子铺类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BaoZiPu extends Thread &#123; private BaoZi baozi; public BaoZiPu(BaoZi baozi) &#123; this.baozi = baozi; &#125; @Override public void run() &#123; int count = 0; while (true) &#123; synchronized (baozi) &#123; if (baozi.flag == true) &#123; try &#123; baozi.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (count % 2 == 0) &#123; baozi.pi = \"薄皮\"; baozi.xian = \"三鲜馅\"; &#125; else &#123; baozi.pi = \"冰皮\"; baozi.xian = \"牛肉馅\"; &#125; count++; System.out.println(\"正在做\" + baozi.pi + baozi.xian + \"包子\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; baozi.flag = true; baozi.notify(); System.out.println(\"快来吃\" + baozi.pi + baozi.xian + \"包子\"); &#125; &#125; &#125;&#125; 吃货类： 12345678910111213141516171819202122232425262728293031public class ChiHuo extends Thread &#123; private BaoZi bz; public ChiHuo(BaoZi bz)&#123; this.bz = bz; &#125; @Override public void run() &#123; while (true)&#123; synchronized (bz)&#123; if (bz.flag==false)&#123; try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"我要开吃了，包子真香\"); bz.flag = false; bz.notify(); System.out.println(\"老板，起来做包子了\"); System.out.println(\"----------------------------\"); &#125; &#125; &#125;&#125; 测试类： 123456789public class Demo &#123; public static void main(String[] args) &#123; BaoZi bz = new BaoZi(); new BaoZiPu(bz).start(); new ChiHuo(bz).start(); &#125;&#125; 执行结果： 123456789101112131415正在做薄皮三鲜馅包子快来吃薄皮三鲜馅包子我要开吃了，包子真香老板，起来做包子了----------------------------正在做冰皮牛肉馅包子快来吃冰皮牛肉馅包子我要开吃了，包子真香老板，起来做包子了----------------------------正在做薄皮三鲜馅包子快来吃薄皮三鲜馅包子我要开吃了，包子真香老板，起来做包子了---------------------------- 6.线程池​ 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。使用Executors工具类的newFixedThreadPool(nThreads)方法获取线程池对象，参数传入线程数。 123456789101112131415161718192021public class RunnableImpl implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \"创建了一个新的线程\"); &#125;&#125;public class Demo01ThreadPool &#123; public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(2); RunnableImpl rb = new RunnableImpl(); es.submit(rb); es.submit(rb); es.submit(rb); //es.shutdown();//不建议关掉 &#125;&#125; 代码的优化——Lambda表达式在运用匿名内部类的时候可以使用Lambda表达式，前提是使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法(函数式接口)。 函数式接口（也可以包含静态,默认,私有的方法）接口之上可以加入注@FunctionalInterface，若接口不满足函数式接口时，该注解会有编译时异常。 使用Lambda必须具有上下文推断。Lambda表达式的格式如下： 1(参数类型 参数名称) -&gt; &#123; 代码语句 &#125; 在Lambda标准格式的基础上，使用省略写法的规则为：小括号内参数的类型可以省略；如果小括号内有且仅有一个参，则小括号可以省略；如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 1234567public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"新的线程\"); &#125;).start(); new Thread(() -&gt; System.out.println(Thread.currentThread().getName() + \"新的线程\")).start(); &#125; 四个常用的函数式接口1.生产接口Supplier接口 该接口下包含一个无参数的方法T get(),用来获取一个泛型参数指定类型的对象数据。 2.消费接口Consumer接口 包含抽象方法void accept(T t),意为消费一个指定泛型的数据。 默认方法andThen()参数和返回值都属Consumer类型，可以实现：首先消费一次，再消费一次，实现组合。 3.判断接口Predicate接口 包含抽象方法boolean test(T t).用于判断返回一个boolean类型的值。 默认方法and()起到了逻辑关系并且的作用。 默认方法or():起到了逻辑关系或的作用。 默认方法negate():起到了逻辑关系非的作用。 4.转换接口Function接口 Function:泛型有两个参数，把T类型转换为R类型。 R apply(T t),根据类型T的参数获取类型R的结果。 默认方法andThen():一个拼接的作用，需要注意的是:当第一次调用apply方法更改参数类型之后，andThen括号内的对象第二次调用时apply()传入的类型为前一次转换之后类型的结果。类似与流水线。 I/O流1.File类及其递归遍历File类是文件和目录路径的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 三个常用构造方法： public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 File类的常用方法查询api可以得到。不再一一举例，下面为File的递归遍历。 遍历有两种方法，file.list()返回一个String数组，表示该File目录中的所有子文件或目录。file.listFiles(括号内可传入过滤器实现类对象)返回一个File数组，表示该File目录中的所有的子文件或目录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class Demo01Filter &#123; public static void main(String[] args) &#123; File f = new File(\"E:\\\\HTML\\\\index\");// long length = getLength(f);// System.out.println(length);// int count = getCount(f);// System.out.println(count); HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); getKind(f, map); System.out.println(map); getAll(f); &#125; //递归删除文件及文件夹 public static void delete(File f) &#123; if (f.isDirectory()) &#123; System.out.println(f); File[] files = f.listFiles(); for (File file : files) &#123; delete(file); &#125; f.delete(); &#125; else &#123; f.delete(); &#125; &#125; //递归遍历打印所有文件夹以及文件名称 public static void getAll(File f) &#123; if (f.isDirectory()) &#123; System.out.println(f); File[] files = f.listFiles(); for (File file : files) &#123; getAll(file); &#125; &#125; else &#123; System.out.println(f); &#125; &#125; //递归获取文件夹下所有文件大小总和或者文件大小 public static long getLength(File f) &#123; if (f.isDirectory()) &#123; long length = 0L; File[] files = f.listFiles(); for (File file : files) &#123; length += getLength(file); &#125; return length; &#125; else &#123; return f.length(); &#125; &#125; //递归打印java总数 public static int getCount(File f) &#123; int sum = 0; if (f.isDirectory()) &#123; File[] files = f.listFiles(); for (File file : files) &#123; sum += getCount(file); &#125; return sum; &#125; else &#123; if (f.getName().endsWith(\".java\")) &#123; return 1; &#125; return 0; &#125; &#125; //递归将类型--&gt;数量存入Map集合 public static void getKind(File f, HashMap&lt;String, Integer&gt; map) &#123; if (f.isDirectory()) &#123; File[] files = f.listFiles(); for (File file : files) &#123; getKind(file, map); &#125; &#125; else &#123; String name = f.getName(); String[] split = name.split(\"\\\\.\"); String kind = split[split.length - 1]; Integer integer = map.get(kind); if (integer == null) &#123; integer = 0; &#125; integer++; map.put(kind, integer); &#125; &#125;&#125; FileFilter：文件过滤器。实现FileFilter中的accept方法可对文件进行过滤，根据pathname将满足条件的文件、文件夹返回ture，不满足的返回false即可。 12345678910public class FileFilterImpl implements FileFilter &#123; @Override public boolean accept(File pathname) &#123; if(pathname.getName().endsWith(\".html\")||pathname.isDirectory())&#123; return true; &#125; return false; &#125;&#125; 2.文件字节流输出流FileOutputStream(写入数据 由内存写出数据到其他设备)​ 1.构造方法 ​ FileOutputStream(File file):构造方法传入File对象表示的文件创建文件输出流 ​ FileOutputStream(String name):构造方法传入指定名称表示的文件创建文件输出流 ​ 2.写出字节数据（单个字节、多个字节） ​ write(int b):每次写出一个字节的数据 ​ write(byte[] b):写出一个字节数组中的数据 ​ write(byte[] b, int off, int len):从索引off开始，len个字节 ​ 3.数据追加、写出换行 ​ 数据追加即在构造方法中的第二个参数设置为true即可，换行符号为 \\r\\n 写出到文件即可。 ​ 4.close()方法关闭文件 ​ 为什么一定要调用close()方法关闭资源？因为如果不关闭资源，程序一旦无限循环时，资源文件就会一直打开无法关闭，我们就无法对文件进行删除等操作。 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) throws IOException &#123; //每次写出一个字节 FileOutputStream fos = new FileOutputStream(\"IOAndProperties\\\\a.txt\"); fos.write((int)('a')); fos.write((int)('9')); fos.write((int)('7')); fos.close(); &#125;public static void main(String[] args) throws IOException &#123; //每次写出一个字节数组或写出字节数组中索引位置起len个长度的数据 FileOutputStream fos = new FileOutputStream(\"IOAndProperties\\\\b.txt\"); byte[] bytes = &#123;97, 98, 99, 100, 101&#125;; fos.write(bytes); fos.write(bytes, 2, 2); byte[] bytes1 = \"你好\".getBytes(); fos.write(bytes1); fos.close(); &#125;public static void main(String[] args) throws IOException &#123; //数据追加以及换行 FileOutputStream fos = new FileOutputStream(\"IOAndProperties\\\\b.txt\"); for (int i = 0; i &lt; 1000; i++) &#123; fos.write(\"你好\".getBytes()); fos.write(\"\\r\\n\".getBytes()); &#125; fos.close(); &#125; 3.文件字节流输入流FileInputStream(读取数据 由其他设备读取数据到内存)​ 1.构造方法 ​ FileInputStream(File file):构造方法传入File对象表示的文件创建文件输入流 ​ FileInputStream(String name):构造方法传入指定名称表示的文件创建文件输入流 ​ 2.读取字节 ​ read():每次读取一个字节的数据，提升为int类型返回（例如读取文件中字符a的时候，返回97），读取到末尾时返回-1； ​ read(byte[] b):每次读取b的长度个字节到数组中，方法返回的是读取字节的个数，读取到末尾时返回-1； ​ 3.close()方法关闭文件 12345678910111213141516171819202122public static void main(String[] args) throws IOException &#123; //每次读取一个字节，循环读取 FileInputStream fis = new FileInputStream(\"IOAndProperties\\\\a.txt\"); int len = 0; while ((len = fis.read() )!=-1)&#123; System.out.println((char)len); &#125; fis.close(); &#125;public static void main(String[] args) throws IOException &#123; //一次读取一个字节数组的内容 FileInputStream fis = new FileInputStream(\"IOAndProperties\\\\b.txt\"); int len = 0; byte[] bys = new byte[1024]; while ((len = fis.read(bys)) != -1) &#123; System.out.println(new String(bys, 0, len));//打印有效的内容 &#125; &#125; 4.字节流之间的图片复制​ 首先用字节输入流从硬盘中读取一张图片，再利用字节输出流把读到的信息写出到另一个文件，达到了复制图片的效果。 123456789101112131415public static void main(String[] args) throws IOException &#123; File f = new File(\"图片\\\\14-58-38-pnsexp271527.jpg\"); FileInputStream fis = new FileInputStream(f); FileOutputStream fos = new FileOutputStream(f.getName()); int len; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) &#123; fos.write(bytes, 0, len); &#125; fos.close(); fis.close(); &#125; 5.字符输出流FileWiter​ 字符流的本质是字节流+编码集（IDEA为UTF-8)。 ​ 1.构造方法 ​ FileWiter(File file):创建一个新的FileWriter，给定要读取的File对象。 ​ FileWriter(String fileName):创建一个新的FileWriter，给定要读取的文件路径。 ​ 2.写出字符数据 ​ write(int b):每次写出一个字符数据。 ​ write(char[] cbuf):每次写出一个字符数组的数据。 ​ write(char[] cbuf, int off , int len):从索引off开始写len个字符 ​ write(String str)和write(String str, int off, int len):每次可以写出字符串当中的数据。 ​ 3.关闭和刷新 ​ 由于每次调用write方法会先把数据写入内存缓冲区，不关闭输出流，无法写字符到文件中。但是关闭数据流无法继续写数据，此时需要用到flush()方法：刷新缓冲区，把字符写入文件。close()方法：先刷新缓冲区，再释放资源。 1234567891011121314public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter(\"IOAndProperties\\\\a.txt\", true); char[] c = &#123;'a', 'b', 'c', 'd', 'e'&#125;; fw.write(c); fw.flush(); fw.write(c, 2, 3); fw.write(\"\\r\\n\"); fw.write(\"dashazi\", 2, 5); fw.flush(); fw.close(); &#125; 6.字符输入流FileReader​ 1.构造方法 ​ FileReader(File file):创建一个新的FileReader，给定要读取的File对象。 ​ FileReader(String fileName):创建一个新的FileReader，给定要读取的文件路径。 ​ 2.读取字符数据 ​ read():每次读取一个字符的数据，提升为int类型，返回回来，读取到文件的末尾返回-1。 ​ read(char[] cbuf)，每次读取cbuf的长度个字符到数组中，返回读取的有效字符个数，读取到末尾时返回-1。 ​ 3.关闭资源 123456789101112131415161718192021public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader(\"IOAndProperties\\\\a.txt\"); int len; len = fr.read(); System.out.println((char)len); while ((len = fr.read()) != -1) &#123; System.out.print(len); &#125; fr.close();// fr = new FileReader(\"09_IOAndProperties\\\\a.txt\");// char[] c = new char[1024];// while ((len = fr.read(c)) != -1) &#123;// System.out.print(new String(c, 0, len));// &#125;//// fr.close(); &#125; 7.IO异常处理JDK7/JDK9新特性​ 1.JDK7的处理 ​ 把创建字符/字节的输出/输入流语句放入try()中，try-catch模块执行完自动释放资源。不用手动的close()。 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 123456789101112131415161718public static void main(String[] args) &#123; try (FileReader fr = new FileReader(\"IOAndProperties\\\\a.txt\"); FileWriter fw = new FileWriter(\"IOAndProperties\\\\d.txt\")) &#123; int len; char[] c = new char[1024]; while ((len = fr.read(c)) != -1) &#123; fw.write(c, 0, len); fw.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; ​ 2.JDK9的处理 ​ 把字符/字节的输出/输入流对象放入try()中，try-catch模块执行完自动释放资源。 12345678910111213141516171819public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader(\"IOAndProperties\\\\a.txt\"); FileWriter fw = new FileWriter(\"IOAndProperties\\\\d.txt\"); try(fr;fw) &#123; int len; char[] c = new char[1024]; while ((len = fr.read(c)) != -1) &#123; fw.write(c, 0, len); fw.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 8.Properties类继承于Hashtable，是一个集合，存储的键值都是字符串类型。 setProperty(String key, String value):存储数据。 getProperty(String key):根据键找值。 Set StringPropertyNames():获取所有键的Set集合。 load(InputStream inStream):从字节输入流读取键值对（键与值之间可以是‘=’、‘ ’，注释用#）。 load(Reader reader):从字符输入流读取键值对（内容可以包含中文，字节流不可以）。 p.store(FileOutputStream outStream, String comments):从字节输出流写出键值对。 p.store(Writer witer, String comments):从字符输出流写出键值对（内容可以包含中文，字节流不可以）。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) throws IOException &#123; show03(); &#125; private static void show03() throws IOException &#123; Properties prop = new Properties(); prop.load(new FileReader(\"IOAndProperties\\\\prop.txt\")); Set&lt;String&gt; set = prop.stringPropertyNames(); for (String key : set) &#123; String value = prop.getProperty(key); System.out.println(key + \"=\" + value); &#125; &#125; private static void show02() throws IOException &#123; Properties p = new Properties(); p.setProperty(\"小西瓜\", \"顶呱呱\"); p.setProperty(\"xia\", \"sdds\"); p.setProperty(\"小西\", \"顶呱\"); p.store(new FileWriter(\"IOAndProperties\\\\prop.txt\"), \"save data\"); //p.store(new FileOutputStream(\"IOAndProperties\\\\prop.txt\"),\"save data\"); &#125; private static void show01() &#123; Properties p = new Properties(); p.setProperty(\"小西瓜\", \"顶呱呱\"); p.setProperty(\"xia\", \"sdds\"); p.setProperty(\"小西\", \"顶呱\"); Set&lt;String&gt; names = p.stringPropertyNames(); for (String name : names) &#123; String value = p.getProperty(name); System.out.println(name + \"=\" + value); &#125; &#125; 9.缓冲流​ 缓冲流，也叫做高效流、包装流，是对四个基本流的增强，创建流对象时会创建一个内置默认大小的缓冲区数组，通过缓冲区读写，减少系统的IO次数，从而提高读写的效率。 1.字节缓冲流 ​ public BufferedInputStream(InputStream in):传入一个字节输入流，创建出一个新的缓冲输入流。 ​ public BufferedOutputStream(OutputStream out):传入一个字节输出流，创建出一个新的缓冲输出流。缓冲字节输出流也需要flush()方法。 ​ 缓冲字节流基本方法和普通字节流一致。 2.字符缓冲流 ​ public BufferedReader(Reader in):传入一个字符输入流，创建出一个新的缓冲输入流。 ​ public BufferedWriter(Writer out):传入一个字节输出流，创建出一个新的缓冲输出流。缓冲字符输出流也需要flush()方法。 ​ 缓冲字符流基本方法和普通字符流一致。 ​ BufferedReader里面包含一个特有方法：readLine():一次读取一行文字，返回一个字符串。但是读不到换行符。 ​ BufferedWriter里面包含的特有方法：newLine():写一个换行符，此方法可以跨平台使用。 ​ 缓冲流文件复制案例： 123456789101112131415public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(\"IO\\\\b.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"IO\\\\c.txt\")); String len; while ((len = br.readLine()) != null) &#123; bw.write(len); bw.newLine(); bw.flush(); &#125; bw.close(); br.close(); &#125; 10.转换流​ 转换流是用普通字节流加上字符集组成。 ​ InputSreamReader(InputStream in,String charsetName):创建一个指定字符集的转换输入字符流，第二个参数不写会使用默认字符集（例如IDEA使用utf-8字符集）。 ​ OutputStreamWriter(OutputStream out,String charsetName):创建一个指定字符集的转换输出字符流，第二个参数不写会使用默认字符集（例如IDEA使用utf-8字符集）。 案例：读取GBK文件，写出UTF-8文件 12345678910111213public static void main(String[] args) throws IOException &#123; InputStreamReader isr = new InputStreamReader(new FileInputStream(\"IO\\\\f.txt\"), \"GBK\"); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"f.txt\"), \"UTF-8\"); int len; char[] c = new char[1024]; while ((len = isr.read(c)) != -1) &#123; osw.write(c, 0, len); osw.flush(); &#125; osw.close(); isr.close(); &#125; 11.序列化及反序列化​ 1.序列化：用一个字节序列表示一个对象，将该对象信息写出到文件。 ​ ObjectOutputStream(OutputStream out)将Java对象的原始数据类型写出到文件，实现对象的持久存储。构造方法内传入一个字节输出流对象。 ​ 一个对象（例如：Student类对象）要想序列化，必须实现Serializable接口作为可以被序列化的标记，另外此类要重写serialVersionUID这个参数，避免该类修改序列号改变引起异常。 ​ 若是某个属性不想被序列化，可以加transient关键词修饰。可避免被序列化。 ​ 调用writeObject(Object obj)方法写出指定对象。 ​ 2.反序列化：用该字节序列从文件中读取出来，重构对象。 ​ ObjectInputStream(InputStream in):构造传入一个字节输入流对象。 ​ 调用readObject()方法读取一个对象，如果想使用该对象的特有方法，我们则需要向下强转。 ​ 由于读取对象没有结束标志，读完会产生一个异常，所以有多个对象时我们可以把它们写在一个集合当中，此时序列化时，直接将集合对象写出到文件当中，这样就可以写一次、读一次避免异常。 ​ 序列化集合案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Person类：public class Person implements Serializable &#123; private static final long serialVersionUID = 7551517898504602762L; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125;ObjectOutputStream类：public class Demo01ObjectOutputStream &#123; public static void main(String[] args) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"IO\\\\g.txt\")); ArrayList&lt;Person&gt; arr = new ArrayList&lt;&gt;(); arr.add(new Person(\"小李\",18)); arr.add(new Person(\"sss\",20)); arr.add(new Person(\"3s\",18)); oos.writeObject(arr); oos.flush(); oos.close(); &#125;&#125;ObjectInputStream类：public class Demo02ObjectInputStream &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"IO\\\\g.txt\")); Object o = ois.readObject(); ArrayList&lt;Person&gt; arr = (ArrayList&lt;Person&gt;) o; for (Person person : arr) &#123; System.out.println(person.getName() + \":\" + person.getAge()); &#125; ois.close(); &#125;&#125; 12.打印流PrintStream​ 打印流的好处：可以使用print、println方法打印，后者自带换行。在构造方法可以指定编码集，自动刷新。打印的数据类型都保持原样。 ​ PrintStream(String fileName):构造方法中传入文件路径。 ​ System.setOut(PrintStream ps):可以改变打印流的流向，把输出到控制台的信息直接输出在文件里。 1234567891011public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream(\"10_IO\\\\print.txt\"); ps.println(97); ps.println(19.88); ps.println(true); ps.println(\"sss\"); ps.close(); &#125; 网络编程​ Tcp协议的三次握手： ​ 第一次握手，客户端向服务器端发出连接请求，等待服务器请求。 ​ 第二次握手，服务端向客户端回送一个回应，通知客户端收到了连接请求。 ​ 第三次握手，客户端再次向服务器端发送确认信息，确认连接。 1.Socket类​ public Socket(String host, int port):创建套接字对象并将其连接到主机上的指定端口号。如果制定的host是null，则相当于指定地址为回环地址(127.0.0.1). ​ host指定IP地址，port指定端口号。 ​ getInputStream():返回此套接字的输入流。 ​ getOutputStream():返回此套接字的输出流。 ​ close():关闭套接字。 ​ shutdownOutput():禁用此套接字的输出流。可以理解为写出了结束标志。 2.ServerSocket类​ public ServerSocket(int port):使用该方法创建ServerSocket对象时，将其绑定到指定端口号上。 ​ public Socket accept():侦听并接受连接，返回一个Socket对象，用于和客户端实现通信，该方法会一直阻塞直到建立连接。 客户端向服务端上传图片案例：服务器端使用无线循环和多线程，能多次接收上传减少耗时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Runnable的实现类：public class RunnableImpl implements Runnable &#123; private Socket socket; public RunnableImpl() &#123; &#125; public RunnableImpl(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try&#123; InputStream is = socket.getInputStream(); File file = new File(\"d:\\\\upload\"); if (!file.exists()) &#123; file.mkdir(); &#125; String fileName = \"wenc\" + System.currentTimeMillis() + new Random().nextInt(999999) + \".png\"; FileOutputStream fos = new FileOutputStream(file.getAbsoluteFile() + \"\\\\\" + fileName); int len; byte[] bytes = new byte[1024]; while ((len = is.read(bytes)) != -1) &#123; fos.write(bytes, 0, len); &#125; fos.close(); OutputStream os = socket.getOutputStream(); os.write(\"上传成功\".getBytes()); socket.shutdownOutput(); socket.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125;服务器端代码：public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ssk = new ServerSocket(8888); ExecutorService es = Executors.newFixedThreadPool(100); while (true) &#123; Socket socket = ssk.accept(); es.submit(new RunnableImpl(socket)); &#125; &#125;&#125;客户端代码：public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream(\"Net\\\\dsj.png\"); Socket sc = new Socket(\"127.0.0.1\", 8888); OutputStream os = sc.getOutputStream(); int len; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) &#123; os.write(bytes, 0, len); &#125; sc.shutdownOutput(); fis.close(); InputStream is = sc.getInputStream(); while ((len = is.read(bytes)) != -1) &#123; System.out.println(new String(bytes, 0, len)); &#125; sc.close(); &#125;&#125; 服务端和客户端实现实时聊天：客户端和服务端都采取了多线程，把读取的数据和写出的数据分别无线循环达到了实时发送、接收消息的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126服务器端代码：public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ssk = new ServerSocket(9999); Socket socket = ssk.accept(); new Thread(new SRunImpl(socket)).start(); new Thread(new SerRunImpl(socket)).start(); &#125; static class SRunImpl implements Runnable &#123; private Socket socket; public SRunImpl(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; while (true) &#123; InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line; line = br.readLine(); System.out.println(\"客户端：\" + line); if (line.equals(\"886\")) &#123; break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class SerRunImpl implements Runnable&#123; private Socket socket; public SerRunImpl(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; Scanner sc = new Scanner(System.in); while (true) &#123; OutputStream out = socket.getOutputStream(); BufferedWriter ps = new BufferedWriter(new OutputStreamWriter(out)); System.out.println(\"给客户端说什么：\"); String str = sc.next(); ps.write(str); ps.newLine(); ps.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;客户端代码：public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\", 9999); new Thread(new SRunImpl(socket)).start(); new Thread(new SerRunImpl(socket)).start(); &#125; static class SRunImpl implements Runnable &#123; private Socket socket; public SRunImpl(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; while (true) &#123; InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line; line = br.readLine(); System.out.println(\"服务端：\" + line); if (line.equals(\"886\")) &#123; break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class SerRunImpl implements Runnable&#123; private Socket socket; public SerRunImpl(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; Scanner sc = new Scanner(System.in); while (true) &#123; OutputStream out = socket.getOutputStream(); BufferedWriter ps = new BufferedWriter(new OutputStreamWriter(out)); System.out.println(\"给服务端说什么：\"); String str = sc.next(); ps.write(str); ps.newLine(); ps.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Stream流Stream是Java 8新加入的最常用的接口。元素是特定类型的对象，形成一个队列。Stream并不会存储元素，而是按需计算，流的来源可以是数组，集合等。Stream流提供了内部迭代方式，流可以直接调用最终方法。 1.获取Stream流Collection获取流：用.stream()获取流。 Map获取流：先转换为keySet()和entrySet(),然后再.stream()获取流。 数组获取流：用Sream.of()方法获取流。 2.常用方法延迟方法：过滤方法filter，此方法参数传入一个判断接口(Predicate)的Lambda表达式，返回true保留，返回false则过滤。 ​ 映射方法map,此方法传入一个转换接口(Function)的Lambda表达式，将stream流当中的格式转换。 ​ 截取方法limit(n),传入一个长度，只取用前n个(包括n),如果集合当前长度大于参数则进行截取；否则不进行操作。 ​ 跳过方法skip(n),跳过前n个元素(包括n)。 ​ 组合方法concat(),将两个流合并为一个流。 终结方法：逐一处理方法foreach，方法内传入一个消费接口(Consumer)的Lambda表达式，一般用于集合数据打印。 ​ 统计个数方法count(),计算流中的元素个数。 ​ 存储到集合collect(Collectors.toList())，将流中的数据存储到集合里。 ​ 存储到数组toArray()，将流中的数据存储到数组里。 反射1.获取Class对象的方式123456781. Class.forName(\"全类名\")：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类2. 类名.class：通过类名的属性class获取 多用于参数的传递3. 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式结论：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 2.Class对象功能12345678910111213141516171819202122232425262728293031获取功能：1. 获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 2. 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;... parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 获取全类名 String getName() Field：成员变量操作：1. 设置值 void set(Object obj, Object value) 2. 获取值 get(Object obj) 3. 忽略访问权限修饰符的安全检查：setAccessible(true):暴力反射Constructor：构造方法创建对象：T newInstance(Object... initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法Method：方法对象执行方法：Object invoke(Object obj, Object... args) 获取方法名称：String getName:获取方法名","categories":[],"tags":[]}]}